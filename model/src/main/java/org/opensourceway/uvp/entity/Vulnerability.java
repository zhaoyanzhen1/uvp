package org.opensourceway.uvp.entity;

import com.vladmihalcea.hibernate.type.array.ListArrayType;
import com.vladmihalcea.hibernate.type.json.JsonBinaryType;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Convert;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import org.apache.commons.collections4.CollectionUtils;
import org.hibernate.annotations.Type;
import org.opensourceway.uvp.enums.OsvSchemaVersion;
import org.opensourceway.uvp.enums.VulnSource;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;

/**
 * Describes a vulnerability.
 */
@Entity
@Table(indexes = {
        @Index(name = "vuln_source_uk", columnList = "vuln_id, source", unique = true),
        @Index(name = "vuln_id_idx", columnList = "vuln_id"),
        @Index(name = "vuln_source_idx", columnList = "source")
})
public class Vulnerability {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    /**
     * OSV Schema Version.
     */
    @Convert(converter = OsvSchemaVersion.OsvSchemaVersionConverter.class)
    @Column(columnDefinition = "TEXT")
    private OsvSchemaVersion schemaVersion;

    /**
     * Unique identifier of a vulnerability.
     * <p>For example:</p>
     * <pre>
     *      1. <a href="https://www.cve.org">CVE</a>
     *      2. <a href="https://github.com/advisories">GHSA ID</a>
     *      3. ...
     * </pre>
     */
    @Column(columnDefinition = "TEXT", name = "vuln_id", nullable = false)
    private String vulnId;

    /**
     * Unique identifiers of related vulnerabilities.
     */
    @Column(columnDefinition = "TEXT[]")
    @Type(ListArrayType.class)
    private List<String> related;

    /**
     * The time a vulnerability entry was last modified.
     */
    @Column(columnDefinition = "TIMESTAMP WITH TIME ZONE")
    private Timestamp modified;

    /**
     * The time a vulnerability entry was published.
     */
    @Column(columnDefinition = "TIMESTAMP WITH TIME ZONE")
    private Timestamp published;

    /**
     * The time a vulnerability entry was withdrawn.
     */
    @Column(columnDefinition = "TIMESTAMP WITH TIME ZONE")
    private Timestamp withdrawn;

    /**
     * The summary of a vulnerability.
     */
    @Column(columnDefinition = "TEXT")
    private String summary;

    /**
     * Vulnerability detail.
     */
    @Column(columnDefinition = "TEXT")
    private String detail;

    /**
     * JSON object that holds additional information about a vulnerability as defined by the database from which the
     * entry was obtained.
     * <p>Especially for information about a vulnerability itself.</p>
     */
    @Column(columnDefinition = "JSONB")
    @Type(value = JsonBinaryType.class)
    private Map<Object, Object> databaseSpecific;

    /**
     * The source database from which a vulnerability was obtained.
     */
    @Convert(converter = VulnSource.VulnSourceConverter.class)
    @Column(columnDefinition = "TEXT", nullable = false)
    private VulnSource source;

    /**
     * Whether the vulnerability is newly inserted.
     */
    @Column
    private Boolean inserted;

    /**
     * Whether the vulnerability is newly updated.
     */
    @Column
    private Boolean updated;

    /**
     * The seriousness of a vulnerability.
     */
    @OneToMany(mappedBy = "vulnerability", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Severity> severities = new ArrayList<>();

    /**
     * The references of a vulnerability.
     */
    @OneToMany(mappedBy = "vulnerability", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Reference> references = new ArrayList<>();

    /**
     * The credits of a vulnerability.
     */
    @OneToMany(mappedBy = "vulnerability", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Credit> credits = new ArrayList<>();

    /**
     * The packages that are affected a vulnerability.
     */
    @OneToMany(mappedBy = "vulnerability", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<AffectedPackage> affectedPackages = new ArrayList<>();

    /**
     * Other unique identifiers of a vulnerability in different databases.
     */
    @OneToMany(mappedBy = "vulnerability", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Alias> aliases = new ArrayList<>();

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public OsvSchemaVersion getSchemaVersion() {
        return schemaVersion;
    }

    public void setSchemaVersion(OsvSchemaVersion schemaVersion) {
        this.schemaVersion = schemaVersion;
    }

    public String getVulnId() {
        return vulnId;
    }

    public void setVulnId(String vulnId) {
        this.vulnId = vulnId;
    }

    public List<String> getRelated() {
        return related;
    }

    public void setRelated(List<String> related) {
        this.related = related;
    }

    public Timestamp getModified() {
        return modified;
    }

    public void setModified(Timestamp modified) {
        this.modified = modified;
    }

    public Timestamp getPublished() {
        return published;
    }

    public void setPublished(Timestamp published) {
        this.published = published;
    }

    public Timestamp getWithdrawn() {
        return withdrawn;
    }

    public void setWithdrawn(Timestamp withdrawn) {
        this.withdrawn = withdrawn;
    }

    public String getSummary() {
        return summary;
    }

    public void setSummary(String summary) {
        this.summary = summary;
    }

    public String getDetail() {
        return detail;
    }

    public void setDetail(String detail) {
        this.detail = detail;
    }

    public Map<Object, Object> getDatabaseSpecific() {
        return databaseSpecific;
    }

    public void setDatabaseSpecific(Map<Object, Object> databaseSpecific) {
        this.databaseSpecific = databaseSpecific;
    }

    public VulnSource getSource() {
        return source;
    }

    public void setSource(VulnSource source) {
        this.source = source;
    }

    public Boolean getInserted() {
        return inserted;
    }

    public void setInserted(Boolean inserted) {
        this.inserted = inserted;
    }

    public Boolean getUpdated() {
        return updated;
    }

    public void setUpdated(Boolean updated) {
        this.updated = updated;
    }

    public List<Severity> getSeverities() {
        return severities;
    }

    public void setSeverities(List<Severity> severities) {
        if (Objects.isNull(this.severities)) {
            this.severities = severities;
        } else {
            this.severities.clear();
            this.severities.addAll(severities);
        }
    }

    public void addSeverity(Severity severity) {
        if (Objects.isNull(this.severities)) {
            this.severities = new ArrayList<>();
        }
        if (!this.severities.contains(severity)) {
            this.severities.add(severity);
            severity.setVulnerability(this);
        }
    }

    public void removeSeverity(Severity severity) {
        if (Objects.isNull(this.severities) || !this.severities.contains(severity)) {
            return;
        }
        this.severities.remove(severity);
        severity.setVulnerability(null);
    }

    public List<Reference> getReferences() {
        return references;
    }

    public void setReferences(List<Reference> references) {
        if (Objects.isNull(this.references)) {
            this.references = references;
        } else {
            this.references.clear();
            this.references.addAll(references);
        }
    }

    public void addReference(Reference reference) {
        if (Objects.isNull(this.references)) {
            this.references = new ArrayList<>();
        }
        if (!this.references.contains(reference)) {
            this.references.add(reference);
            reference.setVulnerability(this);
        }
    }

    public void removeReference(Reference reference) {
        if (Objects.isNull(this.references) || !this.references.contains(reference)) {
            return;
        }
        this.references.remove(reference);
        reference.setVulnerability(null);
    }

    public List<Credit> getCredits() {
        return credits;
    }

    public void setCredits(List<Credit> credits) {
        if (Objects.isNull(this.credits)) {
            this.credits = credits;
        } else {
            this.credits.clear();
            this.credits.addAll(credits);
        }
    }

    public void addCredit(Credit credit) {
        if (Objects.isNull(this.credits)) {
            this.credits = new ArrayList<>();
        }
        if (!this.credits.contains(credit)) {
            this.credits.add(credit);
            credit.setVulnerability(this);
        }
    }

    public void removeCredit(Credit credit) {
        if (Objects.isNull(this.credits) || !this.credits.contains(credit)) {
            return;
        }
        this.credits.remove(credit);
        credit.setVulnerability(null);
    }

    public List<AffectedPackage> getAffectedPackages() {
        return affectedPackages;
    }

    public void setAffectedPackages(List<AffectedPackage> affectedPackages) {
        if (Objects.isNull(this.affectedPackages)) {
            this.affectedPackages = affectedPackages;
        } else {
            this.affectedPackages.clear();
            this.affectedPackages.addAll(affectedPackages);
        }
    }

    public void addAffectedPackage(AffectedPackage affectedPackage) {
        if (Objects.isNull(this.affectedPackages)) {
            this.affectedPackages = new ArrayList<>();
        }
        if (!this.affectedPackages.contains(affectedPackage)) {
            this.affectedPackages.add(affectedPackage);
            affectedPackage.setVulnerability(this);
        }
    }

    public void removeAffectedPackage(AffectedPackage affectedPackage) {
        if (Objects.isNull(this.affectedPackages) || !this.affectedPackages.contains(affectedPackage)) {
            return;
        }
        this.affectedPackages.remove(affectedPackage);
        affectedPackage.setVulnerability(null);
    }

    public List<Alias> getAliases() {
        return aliases;
    }

    public void setAliases(List<Alias> aliases) {
        if (Objects.isNull(this.aliases)) {
            this.aliases = aliases;
        } else {
            this.aliases.clear();
            this.aliases.addAll(aliases);
        }
    }

    public void addAlias(Alias alias) {
        if (Objects.isNull(this.aliases)) {
            this.aliases = new ArrayList<>();
        }
        if (!this.aliases.contains(alias)) {
            this.aliases.add(alias);
            alias.setVulnerability(this);
        }
    }

    public void removeAlias(Alias alias) {
        if (Objects.isNull(this.aliases) || !this.aliases.contains(alias)) {
            return;
        }
        this.aliases.remove(alias);
        alias.setVulnerability(null);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Vulnerability that = (Vulnerability) o;
        return schemaVersion == that.schemaVersion &&
                Objects.equals(vulnId, that.vulnId) &&
                Objects.equals(related, that.related) &&
                Objects.equals(modified, that.modified) &&
                Objects.equals(published, that.published) &&
                Objects.equals(withdrawn, that.withdrawn) &&
                Objects.equals(summary, that.summary) &&
                Objects.equals(detail, that.detail) &&
                source == that.source &&
                // Entity fetched from database will be put in a PersistentBag, which not obeys List equals contract.
                CollectionUtils.isEqualCollection(severities, that.severities) &&
                CollectionUtils.isEqualCollection(references, that.references) &&
                CollectionUtils.isEqualCollection(credits, that.credits) &&
                CollectionUtils.isEqualCollection(affectedPackages, that.affectedPackages) &&
                CollectionUtils.isEqualCollection(aliases, that.aliases);
    }

    @Override
    public int hashCode() {
        return Objects.hash(schemaVersion, vulnId, related, modified, published, withdrawn, summary, detail,
                source, Set.copyOf(severities), Set.copyOf(references), Set.copyOf(credits),
                Set.copyOf(affectedPackages), Set.copyOf(aliases));
    }
}